import { Feature } from 'ol';
import { Point, LineString } from 'ol/geom';
import { NetworkFeatureProperties, ProjectSettings, TimePattern, PumpCurve, NetworkControl } from '@/types/network';
import { useNetworkStore } from '@/store/networkStore';
import { transform } from 'ol/proj';

function getId(f: Feature): string {
    const id = f.getId() || f.get('id');
    return id ? String(id).trim() : 'UNKNOWN_ID';
}

// FIX: Robust padding and number checking
function pad(val: any, width: number = 16): string {
    let str = '0';
    if (val !== undefined && val !== null && !Number.isNaN(val)) {
        str = String(val);
    }
    if (str.length >= width) return str + ' ';
    return str.padEnd(width, ' ');
}

export function generateINP(
    features: Feature[],
    customSettings?: ProjectSettings,
    customPatterns?: TimePattern[],
    customCurves?: PumpCurve[],
    customControls?: NetworkControl[]
): string {
    const lines: string[] = [];

    const store = useNetworkStore.getState();
    const settings = customSettings || store.settings;
    const patterns = customPatterns || store.patterns || [];
    const curves = customCurves || store.curves || [];
    const controls = customControls || store.controls || [];

    const targetProjection = settings.projection || 'EPSG:3857';
    const mapProjection = 'EPSG:3857';
    const shouldTransform = targetProjection !== mapProjection && targetProjection !== 'Simple';

    const hasPattern1 = patterns.some(p => p.id === "1");
    const safePatterns = [...patterns];
    if (!hasPattern1) {
        safePatterns.push({ id: "1", description: "Default", multipliers: Array(24).fill(1.0) });
    }

    // FIX: Case-insensitive type matching
    const getByType = (type: string) => features.filter(f => {
        const t = f.get('type');
        return t && t.toString().toLowerCase() === type.toLowerCase();
    });

    const junctions = getByType('junction');
    const reservoirs = getByType('reservoir');
    const tanks = getByType('tank');
    const pipes = getByType('pipe');
    const pumps = getByType('pump');
    const valves = getByType('valve');

    const allIds = new Set(features.map(getId));

    // --- 1. HEADER ---
    lines.push('[TITLE]');
    lines.push(settings.title || 'EPANET Network generated by Water Network GIS');
    lines.push('');

    // --- 2. OPTIONS ---
    lines.push('[OPTIONS]');
    lines.push(`Units              ${settings.units}`);
    lines.push(`Headloss           ${settings.headloss}`);
    lines.push(`Specific Gravity   ${settings.specificGravity}`);
    lines.push(`Viscosity          ${settings.viscosity}`);
    lines.push(`Trials             ${settings.trials}`);
    lines.push(`Accuracy           ${settings.accuracy}`);
    lines.push('CHECKFREQ          2');
    lines.push('MAXCHECK           10');
    lines.push('DAMPLIMIT          0');
    lines.push('UNBALANCED         Continue 10');
    lines.push('PATTERN            1');
    lines.push('');

    // --- 3. TIMES ---
    lines.push('[TIMES]');
    lines.push('Duration           24:00');
    lines.push('Hydraulic Timestep 1:00');
    lines.push('Pattern Timestep   1:00');
    lines.push('Report Timestep    1:00');
    lines.push('Report Start       0:00');
    lines.push('Start Time         0:00');
    lines.push('Statistic          None');
    lines.push('');

    // --- 4. PATTERNS ---
    lines.push('[PATTERNS]');
    lines.push(';ID   Multipliers');
    safePatterns.forEach(p => {
        const mults = [...p.multipliers];
        while (mults.length < 24) mults.push(1.0);
        const row1 = mults.slice(0, 12).map(v => v.toFixed(2)).join(' ');
        const row2 = mults.slice(12, 24).map(v => v.toFixed(2)).join(' ');
        lines.push(`${p.id}     ${row1}`);
        lines.push(`${p.id}     ${row2}`);
    });
    lines.push('');

    // --- 5. CURVES ---
    if (curves.length > 0) {
        lines.push('[CURVES]');
        lines.push(';ID   X-Value  Y-Value');
        curves.forEach(c => {
            c.points.forEach(pt => {
                lines.push(`${c.id}   ${pt.x}   ${pt.y}`);
            });
            lines.push('');
        });
        lines.push('');
    }

    // --- 6. NETWORK DATA ---
    if (junctions.length > 0) {
        lines.push('[JUNCTIONS]');
        lines.push(';ID              Elevation    Demand       Pattern');
        junctions.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const pat = hasPattern1 ? "1" : "";
            const elev = props.elevation !== undefined ? props.elevation : 0;
            const dem = props.demand !== undefined ? props.demand : 0;
            lines.push(`${pad(getId(f))} ${pad(elev)} ${pad(dem)}                ${pat}   ;`);
        });
        lines.push('');
    }

    if (reservoirs.length > 0) {
        lines.push('[RESERVOIRS]');
        lines.push(';ID              Head         Pattern');
        reservoirs.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const head = props.head !== undefined ? props.head : 100;
            lines.push(`${pad(getId(f))} ${pad(head)}                ;`);
        });
        lines.push('');
    }

    if (tanks.length > 0) {
        lines.push('[TANKS]');
        lines.push(';ID              Elevation    InitLevel    MinLevel     MaxLevel     Diameter     MinVol       VolCurve');
        tanks.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            lines.push(`${pad(getId(f))} ${pad(props.elevation)} ${pad(props.initLevel)} ${pad(props.minLevel)} ${pad(props.maxLevel)} ${pad(props.diameter)} 0            ;`);
        });
        lines.push('');
    }

    if (pipes.length > 0) {
        lines.push('[PIPES]');
        lines.push(';ID              Node1           Node2           Length       Diameter     Roughness    MinorLoss    Status');
        pipes.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const node1 = props.startNodeId || '0';
            const node2 = props.endNodeId || '0';
            const len = props.length || 10;
            const diam = props.diameter || 100;
            const rough = props.roughness || 100;
            const status = props.status || 'Open';
            lines.push(`${pad(getId(f))} ${pad(node1)} ${pad(node2)} ${pad(len)} ${pad(diam)} ${pad(rough)} 0            ${status}`);
        });
        lines.push('');
    }

    if (pumps.length > 0) {
        lines.push('[PUMPS]');
        lines.push(';ID              Node1           Node2           Parameters');
        pumps.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const node1 = props.startNodeId || '0';
            const node2 = props.endNodeId || '0';
            const power = props.power || 50;
            lines.push(`${pad(getId(f))} ${pad(node1)} ${pad(node2)} POWER ${power}`);
        });
        lines.push('');
    }

    if (valves.length > 0) {
        lines.push('[VALVES]');
        lines.push(';ID              Node1           Node2           Diameter     Type         Setting      MinorLoss');
        valves.forEach(f => {
            const props = f.getProperties() as NetworkFeatureProperties;
            const node1 = props.startNodeId || '0';
            const node2 = props.endNodeId || '0';
            lines.push(`${pad(getId(f))} ${pad(node1)} ${pad(node2)} ${pad(props.diameter)} ${props.valveType || 'PRV'} ${props.setting || 0} 0`);
        });
        lines.push('');
    }

    lines.push('[COORDINATES]');
    lines.push(';Node            X-Coord          Y-Coord');
    [...junctions, ...reservoirs, ...tanks].forEach(f => {
        const geom = f.getGeometry() as Point;
        let coords = geom.getCoordinates();

        if (shouldTransform) {
            try {
                coords = transform(coords, mapProjection, targetProjection);
            } catch (e) { }
        }

        const x = coords[0].toFixed(6);
        const y = coords[1].toFixed(6);
        lines.push(`${pad(getId(f))} ${pad(x)} ${pad(y)}`);
    });
    lines.push('');

    lines.push('[VERTICES]');
    lines.push(';Link            X-Coord          Y-Coord');
    [...pipes].forEach(f => {
        const geom = f.getGeometry() as LineString;
        let coords = geom.getCoordinates();

        if (shouldTransform) {
            try {
                coords = coords.map(c => transform(c, mapProjection, targetProjection));
            } catch (e) { }
        }

        for (let i = 1; i < coords.length - 1; i++) {
            lines.push(`${pad(getId(f))} ${pad(coords[i][0].toFixed(6))} ${pad(coords[i][1].toFixed(6))}`);
        }
    });
    lines.push('');

    // --- 7. CONTROLS ---
    if (controls.length > 0) {
        const validControls = controls.filter(c => {
            if (!c.linkId || !allIds.has(c.linkId)) return false;
            if (['LOW LEVEL', 'HI LEVEL'].includes(c.type)) {
                if (!c.nodeId || !allIds.has(c.nodeId)) return false;
            }
            return true;
        });

        if (validControls.length > 0) {
            lines.push('[CONTROLS]');
            validControls.forEach(c => {
                let line = '';
                const linkId = c.linkId.trim();
                const nodeId = c.nodeId ? c.nodeId.trim() : '';

                if (c.type === 'TIMER') {
                    line = `LINK ${linkId} ${c.status} AT TIME ${c.value}`;
                } else {
                    const condition = c.type === 'LOW LEVEL' ? 'BELOW' : 'ABOVE';
                    line = `LINK ${linkId} ${c.status} IF NODE ${nodeId} ${condition} ${c.value}`;
                }
                lines.push(line);
            });
            lines.push('');
        }
    }

    lines.push('[END]');

    return lines.join('\n');
}